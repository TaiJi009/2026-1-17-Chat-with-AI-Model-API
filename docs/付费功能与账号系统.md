# 付费功能与账号系统集成文档

## 目录

- [项目概述](#项目概述)
- [技术架构](#技术架构)
- [系统流程](#系统流程)
- [数据库设计](#数据库设计)
- [API接口文档](#api接口文档)
- [前端实现](#前端实现)
- [后端实现](#后端实现)
- [部署指南](#部署指南)
- [安全考虑](#安全考虑)
- [开发步骤](#开发步骤)

---

## 项目概述

### 功能目标

在现有AI聊天应用基础上，集成完整的账号系统和付费系统，实现：

- **账号系统**: 支持手机号验证码登录/注册
- **付费系统**: 微信支付扫码支付，10元/月订阅Pro功能
- **功能权限**: 夜间模式（dark）免费，日间模式（light）为Pro功能
- **数据存储**: 保持localStorage兼容，支持云端数据同步（可选）

### 技术选型

| 组件 | 技术栈 |
|------|--------|
| 前端 | React 18 + TypeScript + Vite + Tailwind CSS |
| 后端 | Node.js + Express + TypeScript |
| 数据库 | PostgreSQL (Docker容器) |
| 部署 | 腾讯云CVM + Docker + Docker Compose |
| 认证 | JWT Token |
| 支付 | 微信支付 Native支付（扫码） |
| 短信 | 腾讯云短信服务 |
| 前端部署 | GitHub Pages |

---

## 技术架构

### 系统架构图

```mermaid
graph TB
    subgraph Frontend["前端 (GitHub Pages)"]
        A[React App]
        B[AuthContext]
        C[PaymentModal]
        D[ThemeToggle]
    end
    
    subgraph Backend["后端 (腾讯云CVM + Docker)"]
        E[Express API Server]
        F[Auth Controller]
        G[Payment Controller]
        H[JWT Middleware]
    end
    
    subgraph Database["数据库 (Docker)"]
        I[(PostgreSQL)]
        J[users表]
        K[orders表]
        L[sms_codes表]
    end
    
    subgraph External["外部服务"]
        M[微信支付API]
        N[腾讯云短信API]
    end
    
    A --> B
    A --> C
    A --> D
    B --> E
    C --> E
    D --> E
    E --> F
    E --> G
    E --> H
    F --> I
    G --> I
    I --> J
    I --> K
    I --> L
    E --> M
    E --> N
    
    style Frontend fill:#e1f5ff
    style Backend fill:#fff4e1
    style Database fill:#e8f5e9
    style External fill:#fce4ec
```

### 数据流向图

```mermaid
sequenceDiagram
    participant User as 用户
    participant Frontend as 前端
    participant Backend as 后端API
    participant DB as PostgreSQL
    participant WeChat as 微信支付
    participant SMS as 腾讯云短信
    
    Note over User,SMS: 登录流程
    User->>Frontend: 输入手机号
    Frontend->>Backend: POST /api/auth/send-sms
    Backend->>SMS: 发送验证码
    SMS-->>User: 收到验证码
    User->>Frontend: 输入验证码
    Frontend->>Backend: POST /api/auth/verify-sms
    Backend->>DB: 查询/创建用户
    DB-->>Backend: 用户信息
    Backend-->>Frontend: JWT Token + 用户信息
    
    Note over User,WeChat: 支付流程
    User->>Frontend: 点击升级Pro
    Frontend->>Backend: POST /api/payment/create-order
    Backend->>DB: 创建订单
    Backend->>WeChat: 调用统一下单API
    WeChat-->>Backend: 返回二维码URL
    Backend-->>Frontend: 订单ID + 二维码URL
    Frontend->>Frontend: 显示二维码，开始轮询
    User->>WeChat: 扫码支付
    WeChat->>Backend: 支付回调
    Backend->>DB: 更新订单状态 + 用户Pro状态
    Frontend->>Backend: 轮询订单状态
    Backend-->>Frontend: 支付成功
    Frontend->>Frontend: 更新UI，解锁Pro功能
```

---

## 系统流程

### 用户登录流程

```mermaid
flowchart TD
    A[用户访问网站] --> B{是否已登录?}
    B -->|是| C[显示主界面]
    B -->|否| D[显示登录弹窗]
    D --> E[输入手机号]
    E --> F[点击发送验证码]
    F --> G[后端调用腾讯云短信API]
    G --> H[用户收到验证码]
    H --> I[输入验证码]
    I --> J{验证码正确?}
    J -->|否| K[显示错误提示]
    K --> I
    J -->|是| L[后端生成JWT Token]
    L --> M[保存Token到localStorage]
    M --> N[更新用户状态]
    N --> C
```

### 支付流程

```mermaid
flowchart TD
    A[用户点击日间模式] --> B{是否为Pro用户?}
    B -->|是| C[切换到light主题]
    B -->|否| D[显示支付弹窗]
    D --> E[用户点击确认支付]
    E --> F[前端调用创建订单API]
    F --> G[后端创建订单记录]
    G --> H[调用微信支付统一下单API]
    H --> I[返回支付二维码URL]
    I --> J[前端显示二维码]
    J --> K[开始轮询订单状态]
    K --> L[用户扫码支付]
    L --> M[微信支付回调后端]
    M --> N[后端验证签名]
    N --> O{签名正确?}
    O -->|否| P[拒绝回调]
    O -->|是| Q[更新订单状态为paid]
    Q --> R[更新用户Pro状态]
    R --> S[计算Pro到期时间]
    S --> T[前端轮询检测到支付成功]
    T --> U[更新UI，解锁Pro功能]
    U --> C
```

### 主题切换权限控制流程

```mermaid
flowchart TD
    A[用户点击主题切换按钮] --> B{当前主题?}
    B -->|dark| C{目标主题light}
    B -->|light| D[切换到dark]
    C --> E{用户是否为Pro?}
    E -->|是| F[切换到light]
    E -->|否| G[显示支付弹窗]
    G --> H[用户选择支付]
    H --> I[执行支付流程]
    I --> J{支付成功?}
    J -->|是| F
    J -->|否| K[保持dark主题]
    D --> L[更新主题状态]
    F --> L
    K --> L
```

---

## 数据库设计

### 表结构设计

#### 1. 用户表 (users)

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  phone VARCHAR(11) UNIQUE NOT NULL,
  wechat_openid VARCHAR(128) UNIQUE,
  password_hash VARCHAR(255), -- 预留，未来可能支持密码登录
  is_pro BOOLEAN DEFAULT FALSE NOT NULL,
  pro_expires_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP DEFAULT NOW() NOT NULL
);

-- 索引
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_wechat_openid ON users(wechat_openid);
CREATE INDEX idx_users_is_pro ON users(is_pro);
CREATE INDEX idx_users_pro_expires_at ON users(pro_expires_at);

-- 更新时间触发器
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

**字段说明**:
- `id`: 用户唯一标识（UUID）
- `phone`: 手机号（唯一，用于登录）
- `wechat_openid`: 微信OpenID（预留，用于微信登录）
- `password_hash`: 密码哈希（预留）
- `is_pro`: 是否为Pro用户
- `pro_expires_at`: Pro到期时间（NULL表示永久或未开通）
- `created_at`: 创建时间
- `updated_at`: 更新时间

#### 2. 订单表 (orders)

```sql
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  amount DECIMAL(10,2) NOT NULL, -- 金额（元）
  status VARCHAR(20) DEFAULT 'pending' NOT NULL, -- pending, paid, failed, refunded
  payment_method VARCHAR(20) DEFAULT 'wechat' NOT NULL,
  wechat_order_id VARCHAR(64), -- 微信支付订单号（商户订单号）
  wechat_transaction_id VARCHAR(64), -- 微信支付交易号
  wechat_prepay_id VARCHAR(64), -- 微信支付预支付交易会话ID
  created_at TIMESTAMP DEFAULT NOW() NOT NULL,
  paid_at TIMESTAMP,
  expires_at TIMESTAMP, -- Pro到期时间
  CONSTRAINT chk_status CHECK (status IN ('pending', 'paid', 'failed', 'refunded'))
);

-- 索引
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_wechat_order_id ON orders(wechat_order_id);
CREATE INDEX idx_orders_created_at ON orders(created_at);
```

**字段说明**:
- `id`: 订单唯一标识
- `user_id`: 用户ID（外键）
- `amount`: 订单金额（10.00元）
- `status`: 订单状态
- `payment_method`: 支付方式（目前只有wechat）
- `wechat_order_id`: 微信商户订单号
- `wechat_transaction_id`: 微信支付交易号
- `wechat_prepay_id`: 微信预支付ID
- `created_at`: 创建时间
- `paid_at`: 支付时间
- `expires_at`: Pro到期时间

#### 3. 短信验证码表 (sms_codes)

```sql
CREATE TABLE sms_codes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  phone VARCHAR(11) NOT NULL,
  code VARCHAR(6) NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  used BOOLEAN DEFAULT FALSE NOT NULL,
  created_at TIMESTAMP DEFAULT NOW() NOT NULL
);

-- 索引
CREATE INDEX idx_sms_codes_phone ON sms_codes(phone);
CREATE INDEX idx_sms_codes_expires_at ON sms_codes(expires_at);
CREATE INDEX idx_sms_codes_phone_used ON sms_codes(phone, used);

-- 自动清理过期验证码（通过定时任务或应用层逻辑）
```

**字段说明**:
- `id`: 验证码记录ID
- `phone`: 手机号
- `code`: 验证码（6位数字）
- `expires_at`: 过期时间（通常5-10分钟）
- `used`: 是否已使用
- `created_at`: 创建时间

### 数据库关系图

```mermaid
erDiagram
    users ||--o{ orders : "has"
    users {
        uuid id PK
        varchar phone UK
        varchar wechat_openid UK
        boolean is_pro
        timestamp pro_expires_at
    }
    orders {
        uuid id PK
        uuid user_id FK
        decimal amount
        varchar status
        varchar wechat_order_id
        timestamp paid_at
        timestamp expires_at
    }
    sms_codes {
        uuid id PK
        varchar phone
        varchar code
        timestamp expires_at
        boolean used
    }
```

---

## API接口文档

### 基础信息

- **Base URL**: `https://your-api-domain.com/api`
- **认证方式**: JWT Token（Bearer Token）
- **Content-Type**: `application/json`

### 认证相关接口

#### 1. 发送验证码

**接口**: `POST /api/auth/send-sms`

**请求体**:
```json
{
  "phone": "13800138000"
}
```

**响应**:
```json
{
  "success": true,
  "message": "验证码已发送",
  "data": {
    "expiresIn": 300
  }
}
```

**错误响应**:
```json
{
  "success": false,
  "error": "发送频率过高，请稍后再试"
}
```

#### 2. 验证码登录/注册

**接口**: `POST /api/auth/verify-sms`

**请求体**:
```json
{
  "phone": "13800138000",
  "code": "123456"
}
```

**响应**:
```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
      "id": "uuid",
      "phone": "13800138000",
      "isPro": false,
      "proExpiresAt": null
    }
  }
}
```

#### 3. 获取当前用户信息

**接口**: `GET /api/auth/me`

**请求头**:
```
Authorization: Bearer {token}
```

**响应**:
```json
{
  "success": true,
  "data": {
    "id": "uuid",
    "phone": "13800138000",
    "isPro": true,
    "proExpiresAt": "2024-02-01T00:00:00Z"
  }
}
```

#### 4. 刷新Token

**接口**: `POST /api/auth/refresh`

**请求头**:
```
Authorization: Bearer {token}
```

**响应**:
```json
{
  "success": true,
  "data": {
    "token": "new-jwt-token"
  }
}
```

### 支付相关接口

#### 1. 创建支付订单

**接口**: `POST /api/payment/create-order`

**请求头**:
```
Authorization: Bearer {token}
```

**请求体**:
```json
{
  "amount": 10.00,
  "product": "pro_monthly"
}
```

**响应**:
```json
{
  "success": true,
  "data": {
    "orderId": "uuid",
    "amount": 10.00,
    "qrCodeUrl": "weixin://wxpay/bizpayurl?pr=xxx",
    "expiresAt": "2024-01-01T10:05:00Z"
  }
}
```

#### 2. 查询订单状态

**接口**: `GET /api/payment/order/:orderId`

**请求头**:
```
Authorization: Bearer {token}
```

**响应**:
```json
{
  "success": true,
  "data": {
    "orderId": "uuid",
    "status": "paid",
    "amount": 10.00,
    "paidAt": "2024-01-01T10:03:00Z",
    "expiresAt": "2024-02-01T00:00:00Z"
  }
}
```

#### 3. 查询订阅状态

**接口**: `GET /api/payment/subscription`

**请求头**:
```
Authorization: Bearer {token}
```

**响应**:
```json
{
  "success": true,
  "data": {
    "isPro": true,
    "proExpiresAt": "2024-02-01T00:00:00Z",
    "autoRenew": false
  }
}
```

#### 4. 微信支付回调（内部接口）

**接口**: `POST /api/payment/wechat/callback`

**说明**: 此接口由微信支付服务器调用，不需要认证

**请求体**: 微信支付回调XML数据

**响应**: 微信支付要求的XML格式响应

---

## 前端实现

### 文件修改清单

#### 需要修改的现有文件

1. **src/types/index.ts**
   - 添加用户、订单、验证码相关类型定义
   - 扩展AppState添加用户状态

2. **src/contexts/AppContext.tsx**
   - 修改默认主题为`dark`
   - 添加用户状态管理
   - 添加Pro状态检查

3. **src/components/ThemeToggle.tsx**
   - 添加Pro权限检查
   - 非Pro用户显示支付弹窗

4. **src/App.tsx**
   - 集成AuthProvider
   - 添加登录状态检查

#### 需要新建的文件

1. **src/contexts/AuthContext.tsx**
   - 用户认证状态管理
   - Token管理
   - 登录/登出函数

2. **src/components/LoginModal.tsx**
   - 手机号输入
   - 验证码发送和验证
   - 登录/注册UI

3. **src/components/PaymentModal.tsx**
   - 支付二维码显示
   - 支付状态轮询
   - 支付成功提示

4. **src/services/authService.ts**
   - 认证相关API调用

5. **src/services/paymentService.ts**
   - 支付相关API调用

6. **src/utils/apiClient.ts**
   - API请求封装
   - Token自动添加
   - 错误处理

### 核心实现代码示例

#### 1. AuthContext实现

```typescript
// src/contexts/AuthContext.tsx
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { User } from '../types';
import * as authService from '../services/authService';

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (phone: string, code: string) => Promise<void>;
  logout: () => void;
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // 从localStorage加载token
    const token = localStorage.getItem('auth_token');
    if (token) {
      authService.setToken(token);
      refreshUser();
    } else {
      setIsLoading(false);
    }
  }, []);

  const login = async (phone: string, code: string) => {
    const response = await authService.verifySms(phone, code);
    localStorage.setItem('auth_token', response.token);
    authService.setToken(response.token);
    setUser(response.user);
  };

  const logout = () => {
    localStorage.removeItem('auth_token');
    authService.setToken(null);
    setUser(null);
  };

  const refreshUser = async () => {
    try {
      const userData = await authService.getCurrentUser();
      setUser(userData);
    } catch (error) {
      logout();
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        isLoading,
        login,
        logout,
        refreshUser,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

#### 2. ThemeToggle权限控制

```typescript
// src/components/ThemeToggle.tsx (修改后)
import { useApp } from '../contexts/AppContext';
import { useAuth } from '../contexts/AuthContext';
import { useState } from 'react';
import PaymentModal from './PaymentModal';

export default function ThemeToggle() {
  const { state, dispatch } = useApp();
  const { user, isAuthenticated } = useAuth();
  const [showPaymentModal, setShowPaymentModal] = useState(false);

  const toggleTheme = () => {
    const newTheme = state.theme === 'light' ? 'dark' : 'light';
    
    // 如果切换到light主题，检查Pro权限
    if (newTheme === 'light') {
      // 未登录或非Pro用户，显示支付弹窗
      if (!isAuthenticated || !user?.isPro) {
        setShowPaymentModal(true);
        return;
      }
    }
    
    dispatch({ type: 'SET_THEME', payload: newTheme });
  };

  return (
    <>
      <button onClick={toggleTheme}>
        {/* 按钮内容 */}
      </button>
      {showPaymentModal && (
        <PaymentModal
          onClose={() => setShowPaymentModal(false)}
          onSuccess={() => {
            setShowPaymentModal(false);
            dispatch({ type: 'SET_THEME', payload: 'light' });
          }}
        />
      )}
    </>
  );
}
```

#### 3. PaymentModal实现

```typescript
// src/components/PaymentModal.tsx
import { useState, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import * as paymentService from '../services/paymentService';

interface PaymentModalProps {
  onClose: () => void;
  onSuccess: () => void;
}

export default function PaymentModal({ onClose, onSuccess }: PaymentModalProps) {
  const { refreshUser } = useAuth();
  const [qrCodeUrl, setQrCodeUrl] = useState<string>('');
  const [orderId, setOrderId] = useState<string>('');
  const [status, setStatus] = useState<'pending' | 'paid' | 'failed'>('pending');

  useEffect(() => {
    // 创建订单
    const createOrder = async () => {
      try {
        const order = await paymentService.createOrder(10.00, 'pro_monthly');
        setQrCodeUrl(order.qrCodeUrl);
        setOrderId(order.orderId);
        
        // 开始轮询订单状态
        startPolling(order.orderId);
      } catch (error) {
        setStatus('failed');
      }
    };
    
    createOrder();
  }, []);

  const startPolling = (orderId: string) => {
    const interval = setInterval(async () => {
      try {
        const order = await paymentService.getOrderStatus(orderId);
        if (order.status === 'paid') {
          clearInterval(interval);
          setStatus('paid');
          await refreshUser();
          setTimeout(() => {
            onSuccess();
          }, 1000);
        }
      } catch (error) {
        // 轮询错误，继续轮询
      }
    }, 2000); // 每2秒轮询一次

    // 30秒后停止轮询
    setTimeout(() => {
      clearInterval(interval);
    }, 30000);
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
        <h2 className="text-xl font-bold mb-4">升级Pro功能</h2>
        {status === 'pending' && (
          <>
            <p className="mb-4">扫码支付 10元/月</p>
            <img src={qrCodeUrl} alt="支付二维码" className="w-full mb-4" />
            <p className="text-sm text-gray-500">请使用微信扫码支付</p>
          </>
        )}
        {status === 'paid' && (
          <div className="text-center">
            <p className="text-green-600 mb-4">支付成功！</p>
            <p>Pro功能已激活</p>
          </div>
        )}
        <button onClick={onClose} className="mt-4 w-full">关闭</button>
      </div>
    </div>
  );
}
```

---

## 后端实现

### 项目结构

```
backend/
├── src/
│   ├── config/
│   │   ├── database.ts          # 数据库配置
│   │   ├── wechat-pay.ts        # 微信支付配置
│   │   └── sms.ts               # 短信服务配置
│   ├── controllers/
│   │   ├── auth.controller.ts   # 认证控制器
│   │   └── payment.controller.ts # 支付控制器
│   ├── services/
│   │   ├── auth.service.ts      # 认证服务
│   │   ├── payment.service.ts   # 支付服务
│   │   └── sms.service.ts       # 短信服务
│   ├── models/
│   │   ├── user.model.ts        # 用户模型
│   │   └── order.model.ts       # 订单模型
│   ├── middleware/
│   │   ├── auth.middleware.ts   # JWT认证中间件
│   │   └── error.middleware.ts  # 错误处理
│   ├── routes/
│   │   ├── auth.routes.ts       # 认证路由
│   │   └── payment.routes.ts    # 支付路由
│   ├── utils/
│   │   ├── jwt.ts               # JWT工具
│   │   └── validator.ts         # 数据验证
│   └── app.ts                   # Express应用入口
├── docker/
│   ├── Dockerfile               # 后端Dockerfile
│   └── docker-compose.yml      # Docker Compose配置
├── migrations/
│   └── 001_initial.sql         # 数据库迁移脚本
├── .env.example                 # 环境变量示例
├── package.json
└── tsconfig.json
```

### 核心实现代码示例

#### 1. JWT认证中间件

```typescript
// src/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export interface AuthRequest extends Request {
  userId?: string;
}

export function authMiddleware(
  req: AuthRequest,
  res: Response,
  next: NextFunction
) {
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ success: false, error: '未提供认证令牌' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { userId: string };
    req.userId = decoded.userId;
    next();
  } catch (error) {
    return res.status(401).json({ success: false, error: '无效的认证令牌' });
  }
}
```

#### 2. 支付服务实现

```typescript
// src/services/payment.service.ts
import { v4 as uuidv4 } from 'uuid';
import { createOrder as createWechatOrder } from '../config/wechat-pay';
import { Order, User } from '../models';

export async function createPaymentOrder(
  userId: string,
  amount: number
): Promise<{ orderId: string; qrCodeUrl: string }> {
  // 创建数据库订单
  const order = await Order.create({
    id: uuidv4(),
    userId,
    amount,
    status: 'pending',
  });

  // 调用微信支付统一下单API
  const wechatOrder = await createWechatOrder({
    out_trade_no: order.id,
    total_fee: Math.round(amount * 100), // 转换为分
    body: 'Pro功能订阅 - 1个月',
    notify_url: process.env.WECHAT_NOTIFY_URL!,
  });

  // 更新订单的微信订单号
  order.wechatOrderId = wechatOrder.out_trade_no;
  order.wechatPrepayId = wechatOrder.prepay_id;
  await order.save();

  return {
    orderId: order.id,
    qrCodeUrl: wechatOrder.code_url, // 二维码URL
  };
}

export async function handleWechatCallback(data: any): Promise<void> {
  // 验证签名
  // ... 签名验证逻辑

  // 更新订单状态
  const order = await Order.findOne({
    where: { wechatOrderId: data.out_trade_no },
  });

  if (!order) {
    throw new Error('订单不存在');
  }

  if (data.result_code === 'SUCCESS') {
    order.status = 'paid';
    order.wechatTransactionId = data.transaction_id;
    order.paidAt = new Date();
    
    // 计算Pro到期时间（当前时间 + 1个月）
    const expiresAt = new Date();
    expiresAt.setMonth(expiresAt.getMonth() + 1);
    order.expiresAt = expiresAt;

    await order.save();

    // 更新用户Pro状态
    const user = await User.findByPk(order.userId);
    if (user) {
      user.isPro = true;
      user.proExpiresAt = expiresAt;
      await user.save();
    }
  }
}
```

---

## 部署指南

### 服务器环境准备

#### 1. 腾讯云CVM配置

- **配置**: 2核4G内存起步
- **系统**: Ubuntu 20.04 LTS 或 CentOS 7+
- **网络**: 配置安全组，开放80、443、3000端口

#### 2. 安装Docker和Docker Compose

```bash
# 安装Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# 安装Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
```

#### 3. Docker Compose配置

```yaml
# docker/docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: chat_app_postgres
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped

  backend:
    build:
      context: ..
      dockerfile: docker/Dockerfile
    container_name: chat_app_backend
    environment:
      DATABASE_URL: postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/${DB_NAME}
      JWT_SECRET: ${JWT_SECRET}
      WECHAT_APP_ID: ${WECHAT_APP_ID}
      WECHAT_MCH_ID: ${WECHAT_MCH_ID}
      WECHAT_API_KEY: ${WECHAT_API_KEY}
      WECHAT_NOTIFY_URL: ${WECHAT_NOTIFY_URL}
      TENCENT_SMS_SECRET_ID: ${TENCENT_SMS_SECRET_ID}
      TENCENT_SMS_SECRET_KEY: ${TENCENT_SMS_SECRET_KEY}
      TENCENT_SMS_APP_ID: ${TENCENT_SMS_APP_ID}
      TENCENT_SMS_SIGN_NAME: ${TENCENT_SMS_SIGN_NAME}
      TENCENT_SMS_TEMPLATE_ID: ${TENCENT_SMS_TEMPLATE_ID}
      PORT: 3000
      NODE_ENV: production
      CORS_ORIGIN: ${CORS_ORIGIN}
    ports:
      - "3000:3000"
    depends_on:
      - postgres
    restart: unless-stopped

volumes:
  postgres_data:
```

#### 4. Nginx反向代理配置

```nginx
# /etc/nginx/sites-available/chat-app-api
server {
    listen 80;
    server_name api.yourdomain.com;

    # 重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name api.yourdomain.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;

    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
```

### 部署步骤

1. **克隆代码到服务器**
```bash
git clone https://github.com/your-repo/chat-app.git
cd chat-app/backend
```

2. **配置环境变量**
```bash
cp .env.example .env
# 编辑.env文件，填入所有配置
```

3. **运行数据库迁移**
```bash
docker-compose exec backend npm run migrate
```

4. **启动服务**
```bash
docker-compose up -d
```

5. **查看日志**
```bash
docker-compose logs -f
```

---

## 安全考虑

### 1. 认证安全

- **JWT Token**: 使用强密钥，设置合理的过期时间（7天）
- **Token存储**: 优先使用HTTP-only Cookie，或localStorage + 定期刷新
- **密码**: 使用bcrypt哈希（虽然当前只有验证码登录）

### 2. 数据安全

- **SQL注入**: 使用参数化查询（Prisma/TypeORM）
- **XSS防护**: 前端输入验证和转义
- **敏感数据**: 不在日志中记录密码、Token等敏感信息

### 3. 支付安全

- **签名验证**: 严格验证微信支付回调签名
- **订单验证**: 验证订单金额、状态等关键信息
- **幂等性**: 确保支付回调的幂等性处理

### 4. 接口安全

- **CORS**: 配置允许的前端域名
- **Rate Limiting**: 限制API调用频率（特别是验证码接口）
- **HTTPS**: 生产环境必须使用HTTPS

### 5. 服务器安全

- **防火墙**: 只开放必要端口
- **SSH**: 禁用密码登录，使用密钥认证
- **更新**: 定期更新系统和依赖包

---

## 开发步骤

### 阶段1: 后端基础架构 (3-4天)

1. 创建后端项目结构
2. 配置Express + TypeScript
3. 设置PostgreSQL数据库连接
4. 创建数据库迁移脚本
5. 配置Docker和Docker Compose

### 阶段2: 认证系统 (3-4天)

1. 实现JWT Token生成和验证
2. 实现短信验证码发送（腾讯云短信）
3. 实现验证码登录/注册接口
4. 实现用户信息查询接口
5. 添加认证中间件

### 阶段3: 支付系统 (4-5天)

1. 集成微信支付SDK
2. 实现创建订单接口
3. 实现支付二维码生成
4. 实现支付回调处理
5. 实现订单状态查询
6. 实现Pro状态更新逻辑

### 阶段4: 前端集成 (3-4天)

1. 创建认证上下文和登录组件
2. 修改主题切换逻辑（添加Pro检查）
3. 创建支付弹窗组件
4. 集成API调用服务
5. 修改AppContext添加用户状态

### 阶段5: 部署配置 (2-3天)

1. 配置腾讯云CVM服务器
2. 安装Docker和Docker Compose
3. 配置Nginx反向代理
4. 配置SSL证书（HTTPS）
5. 配置环境变量和密钥
6. 部署数据库和后端服务

### 阶段6: 测试和优化 (2-3天)

1. 功能测试（登录、支付、主题切换）
2. 支付流程测试（沙箱环境）
3. 性能测试和优化
4. 错误处理和日志记录
5. 安全加固（SQL注入、XSS防护）

### 阶段7: 文档编写 (1-2天)

1. 创建本文档
2. API接口文档
3. 部署文档
4. 开发指南

---

## 总结

本文档详细描述了账号系统和付费系统的集成方案，包括：

- ✅ 完整的技术架构设计
- ✅ 详细的数据库设计
- ✅ 完整的API接口文档
- ✅ 前端和后端实现指南
- ✅ 部署和安全考虑
- ✅ 开发步骤和时间规划

按照本文档的步骤，可以顺利完成账号系统和付费系统的集成开发。

---

**最后更新**: 2026-01-19 
**文档版本**: v1.0
